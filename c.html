<html>
 <head>
  <title>Lonely Island</title>
  <link rel="stylesheet" href="default.css" type="text/css">
  <script src="util.js" type="text/javascript"></script>
  <script src="network.js" type="text/javascript"></script>
  <script src="game.js" type="text/javascript"></script>
  <script src="board.js" type="text/javascript"></script>
 </head>
<body>


<table>
 <tr>
  <td>
   <img src="img/transparent.gif" id="board_interface" style="width:600px; height: 600px; border: 0; position: absolute; left: 0px; top: -120px; z-index: 100" usemap="#cellmap" />
  </td>
 </tr>
</table>

<map name="cellmap" id="cellmap"></map>
<map name="vertexmap" id="vertexmap"></map>
<map name="edgemap" id="edgemap"></map>

<div id="tiles"></div>
<div id="roads"></div>
<div id="buildings"></div>
<div id="markers"></div>
<div id="robber" style="position:absolute;visibility:hidden;"><img src="img/robber.gif"/></div>

<div id="player_window" class="window" style="left: 600px; top: 20px;"></div>
<div id="dice" class="dice" style="left: 700px; top: 300px;" onmousedown="state.diceHandler();"><img src="img/dice1.png"><img src="img/dice6.png"></div>
<div id="steal_window" class="window" style="left: 700px; top: 500px;visibility:hidden;">Steal from:</div>

<div id="purchase_window" class="window" style="left: 770px; top: 20px;"></div>
<div id="res_window" style="left: 770px; top: 250px;"></div>
<input type="button" value="End Turn" class="window" style="left: 770px; top: 350px;" onclick="state.buttonHandler('button_end_turn');"/>
<div id="log_window" class="window" style="left: 770px; top: 380px; width: 200px; height: 100px; overflow: auto;">Welcome to Lonely Island~</div>
<div id="devcard_window" class="window" style="left: 770px; top: 500px;">Development Cards:</div>

<div id="status" class="window" style="left: 300px; top: 500px;">Status: idle</div>
<div style="top: 500px; position: absolute">
<div onmousedown="regPlayer('cx',0); setupGame(new Array('cx', 'Si', 'phisho')); priv_sendMapData(); priv_startGame();">I am player 0</div>
<div onmousedown="regPlayer('Si',1);">I am player 1</div>
<div onmousedown="regPlayer('cychoi',2);">I am player 2</div>
<div onmousedown="clearRemoteLog();">Clear Data</div>
</div>

</body>

<script language="javascript" src="player.js"></script>
<script language="javascript" src="state.js"></script>
<script language="javascript" src="remote.js"></script>
<script language="javascript" src="devcard.js"></script>

<script type="text/javascript" src="geom.js"></script>
<script language="javascript">

//////////////////////////////////////////////////////// BEGIN CONFIG AND CONSTANTS

game = new Game();

//////////////////////////////////////////////////////// END CONFIG AND CONSTANTS


//////////////////////////////////////////////////////// BEGIN GAME STATE STUFF


board = new Board();

var numPlayers;
var myId;
var cellResources; // 2D array (same size as board)
var cellMarkers; // 2D array (same size as board)
var outcomeCellMap; // 2D array (outcome -> cell)
var robberPos;
var players; // array of Players
var vertexBuildingMap; // coordinates->building
var edgeBuildingMap; // coordinates->building
var vertexReachableMap; // coordinates->array of player IDs
var currentAction;
var currentTurn;
var initRolls;
var tiedPlayers;
var firstPlayer;
var initialSett;


//////////////////////////////////////////////////////// END GAME STATE STUFF


//////////////////////////////////////////////////////// BEGIN GAME SETUP STUFF

function setupGame(playerNames, mapData) {
	numPlayers = playerNames.length;
	players = new Array();
	for (var i = 0; i < numPlayers; ++i)
		players.push(new Player(i, playerNames[i]));
	if (mapData == null)
		randomizeCells();
	else
		loadMap(mapData);
	drawBoard();
	drawMarkers();
	initCellMap();
	initVertexMap();
	initEdgeMap();

	ui_showResourceWindow(myId);
	ui_showPurchaseWindow(myId);
	ui_showPlayerWindow(myId);

	vertexBuildingMap = new Array();
	edgeBuildingMap = new Array();
	vertexReachableMap = new Array();

	initRolls = create1DArray(numPlayers);
	tiedPlayers = new Array();
	for (var i = 0; i < numPlayers; ++i)
		tiedPlayers.push(i);

	changeState('wait');
}

function randomizeCells() {
	var remainTiles = new Array(4, 3, 4, 4, 3);
	var numberMarkers = new Array(6, 2, 5, 3, 4, 9, 10, 8, 11, 3, 8, 10, 5, 6, 4, 9, 12, 11);
	cellResources = create2DArray(board.WIDTH, board.HEIGHT);
	cellMarkers = create2DArray(board.WIDTH, board.HEIGHT);
	outcomeCellMap = new Array();
	robberPos = { i: -999, j: -999 };

	while (true) {
		var i = randInt(board.WIDTH);
		var j = randInt(board.HEIGHT);
		if (isValidCell(i, j)) {
			cellResources[i][j] = game.DESERT;
			pub_placeRobber(i, j, myId);
			break;
		}
	}
	for (var i = 0; i < board.WIDTH; ++i)
		for (var j = 0; j < board.HEIGHT; ++j) {
			if (isValidCell(i, j) && cellResources[i][j] != game.DESERT) {
				while (true) {
					var type = randInt(game.numResourceTypes);
					if (remainTiles[type] > 0) {
						cellResources[i][j] = type;
						remainTiles[type]--;
						break;
					}
				}
				while (true) {
					var mark = randInt(numberMarkers.length);
					var m = numberMarkers[mark];
					if (m > 0) {
						cellMarkers[i][j] = m;
						numberMarkers[mark] = 0;
						if (!outcomeCellMap[m])
							outcomeCellMap[m] = new Array();
						outcomeCellMap[m].push( {i: i, j: j} );
						break;
					}
				}
			}
		}
}

function loadMap(mapData) {
	board.WIDTH = mapData.shift();
	board.HEIGHT = mapData.shift();
	cellResources = create2DArray(board.WIDTH, board.HEIGHT);
	cellMarkers = create2DArray(board.WIDTH, board.HEIGHT);
	outcomeCellMap = new Array();
	robberPos = { i: -999, j: -999 };
	for (var i = 0; i < board.WIDTH; ++i)
		for (var j = 0; j < board.HEIGHT; ++j)
			board.data[i][j] = parseInt(mapData.shift());
	for (var i = 0; i < board.WIDTH; ++i)
		for (var j = 0; j < board.HEIGHT; ++j)
			cellResources[i][j] = parseInt(mapData.shift());
	for (var i = 0; i < board.WIDTH; ++i)
		for (var j = 0; j < board.HEIGHT; ++j) {
			var m = cellMarkers[i][j] = parseInt(mapData.shift());
			if (!outcomeCellMap[m])
				outcomeCellMap[m] = new Array();
			outcomeCellMap[m].push( {i: i, j: j} );
		}
	var x = mapData.shift();
	var y = mapData.shift();
	pub_placeRobber(x, y, myId);
}

function drawBoard() {
	for (var i = 0; i < board.WIDTH; ++i)
	for (var j = 0; j < board.HEIGHT; ++j) 
	if (board.data[i][j]) {
		var tile = document.createElement('img');
		if (board.data[i][j] == 2)
			tile.setAttribute('src', 'img/sea.gif');
		else if (cellResources[i][j] == game.DESERT)
			tile.setAttribute('src', 'img/desert.gif');
		else
			tile.setAttribute('src', 'img/' + game.resourceNames[cellResources[i][j]] + '.gif');
		tile.style.position = 'absolute';
		tile.style.left = (cellXY(i,j).x + game.XDELTA) + 'px';
		tile.style.top = (cellXY(i,j).y + game.YDELTA) + 'px';
		document.getElementById('tiles').appendChild(tile);
	}
}

function drawMarkers() {
	for (var i = 0; i < board.WIDTH; ++i)
	for (var j = 0; j < board.HEIGHT; ++j) 
	if (cellMarkers[i][j] > 0) {
		var marker = document.createElement('div');
		marker.style.backgroundColor = '#ffffff';
		marker.style.position = 'absolute';
		marker.style.left = (cellXY(i,j).x + 30 + game.XDELTA) + 'px';
		marker.style.top = (cellXY(i,j).y + 20 + game.YDELTA) + 'px';
		marker.innerHTML = cellMarkers[i][j];
		document.getElementById('markers').appendChild(marker);
	}
}

function initCellMap() {
	for (var i = 0; i < board.WIDTH; ++i)
	for (var j = 0; j < board.HEIGHT; ++j)
	if (isValidCell(i, j)) {
		var area = document.createElement('area');
		var x = cellXY(i,j).x;
		var y = cellXY(i,j).y;
		area.setAttribute('shape', 'polygon');
		area.setAttribute('coords', (x+18) + ',' + (y) + ',' +
		                            (x+52) + ',' + (y) + ',' +
		                            (x+71) + ',' + (y+31) + ',' +
		                            (x+52) + ',' + (y+63) + ',' +
		                            (x+18) + ',' + (y+63) + ',' +
		                            (x) + ',' + (y+31));
		area.setAttribute('onmousedown', 'state.cellHandler('+i+','+j+');return false;');
		document.getElementById('cellmap').appendChild(area);
	}
}

function initVertexMap() {
	for (var i = -1; i <= board.WIDTH; ++i)
	for (var j = -1; j <= board.HEIGHT; ++j)
	for (var v = 0; v < 2; ++v)
	if (isValidVertex(i, j, v)) {
		var area = document.createElement('area');
		var x = vertexXY(i,j,v).x;
		var y = vertexXY(i,j,v).y;
		area.setAttribute('shape', 'rect');
		area.setAttribute('coords', (x-12) + ',' + (y-12) + ',' +
		                            (x+12) + ',' + (y+12));
		area.setAttribute('onmousedown', 'state.vertexHandler('+i+','+j+','+v+');return false;');
		document.getElementById('vertexmap').appendChild(area);
	}
}

function initEdgeMap() {
	for (var i = -1; i <= board.WIDTH; ++i)
	for (var j = -1; j <= board.HEIGHT; ++j)
	for (var e = 0; e < 3; ++e)
	if (isValidEdge(i, j, e)) {
		var area = document.createElement('area');
		var x1 = vertexXY(i,j,e).x;
		var y1 = vertexXY(i,j,e).y;
		var x2 = vertexXY(i,j,(e+1)%6).x;
		var y2 = vertexXY(i,j,(e+1)%6).y;
		area.setAttribute('shape', 'polygon');
		switch (e) {
			case 0:
				area.setAttribute('coords', (x1+5) + ',' + (y1-7) + ',' +
				                            (x2-5) + ',' + (y2-7) + ',' +
				                            (x2-5) + ',' + (y2+7) + ',' +
				                            (x1+5) + ',' + (y1+7));
				break;
			case 1:
				area.setAttribute('coords', (x1+9) + ',' + (y1+2) + ',' +
				                            (x2+1) + ',' + (y2-9) + ',' +
				                            (x2-9) + ',' + (y2-2) + ',' +
				                            (x1-1) + ',' + (y1+9));
				break;
			case 2:
				area.setAttribute('coords', (x1+1) + ',' + (y1+9) + ',' +
				                            (x2+9) + ',' + (y2-2) + ',' +
				                            (x2-1) + ',' + (y2-9) + ',' +
				                            (x1-9) + ',' + (y1+2));
				break;
		}
		area.setAttribute('onmousedown', 'state.edgeHandler('+i+','+j+','+e+');return false;');
		document.getElementById('edgemap').appendChild(area);
	}
}

//////////////////////////////////////////////////////// BEGIN GAME PROGRESS STUFF

//////////////////////////////////////////// BEGIN UI stuff

function ui_drawDice(a) {
	var txt = '';
	for (var i = 0; i < game.numDice; ++i) {
		txt += '<img src="img/dice'+a[i]+'.png">';
	}
	g('dice').innerHTML = txt;
}

function ui_showResourceWindow(pid) {
	var p = players[pid];
	var txt = '';
	for (var i = 0; i < game.numResourceTypes; ++i)
		txt += '<img src="img/'+game.resourceNames[i]+'_small.gif"> ' + game.resourceNames[i]  + ": " + p.resources[i] + "<br/>";
	g('res_window').innerHTML = txt;
}

function ui_showPurchaseWindow(pid) {
	var p = players[pid];
	var txt = '';

	function dumpCost(a) {
		var s = '';
		for (var i = 0; i < game.numResourceTypes; ++i)
			if (a[i] > 0)
				s += '<img src="img/'+game.resourceNames[i]+'_small.gif">' + ' x' + a[i] + '&nbsp;';
		return s;
	}

	txt += 'Development Card <input type="button" id="button_buy_devcard" value="Buy" style="border:1px solid black;" onclick="state.buttonHandler(\'button_buy_devcard\');return false;"/> (' + remainingDevCards() + ' left)<br/>' + dumpCost(game.cardCost) + '<br/><hr/>';
	txt += 'City <input type="button" id="button_buy_city" value="Buy" style="border:1px solid black;" onclick="state.buttonHandler(\'button_buy_city\');return false;"/> (' + (game.maxCities-players[pid].buildingCounts[game.CITY]) + ' left)<br/>' + dumpCost(game.cityCost) + '<br/><hr/>';
	txt += 'Settlement <input type="button" id="button_buy_sett" value="Buy" style="border:1px solid black;" onclick="state.buttonHandler(\'button_buy_sett\');return false;"/> (' + (game.maxSetts-players[pid].buildingCounts[game.SETT]) + ' left)<br/>' + dumpCost(game.settCost) + '<br/><hr/>';
	txt += 'Road <input type="button" id="button_buy_road" value="Buy" style="border:1px solid black;" onclick="state.buttonHandler(\'button_buy_road\');return false;"/> (' + (game.maxRoads-players[pid].buildingCounts[game.ROAD]) + ' left)<br/>' + dumpCost(game.roadCost) + '<br/><hr/>';

	g('purchase_window').innerHTML = txt;
}

function ui_showPlayerWindow(pid) {
	var txt = '';
	for (var i = 0; i < numPlayers; ++i) {
		txt += '<div style="background-color:' + playerColors[i] + ';">';
		if (currentTurn == i)
			txt += '<b><i><u>' + players[i].name + '</u></i></b><br/>';
		else
			txt += '<b>' + players[i].name + '</b><br/>';
		txt += 'Points: ' + players[i].points() + '<br/>';
		txt += 'Resource cards: ' + players[i].numResources() + '<br/>';
		txt += 'Development cards: ' + players[i].devCards.length + '</div>';
		txt += '<hr/>';
	}
	g('player_window').innerHTML = txt;
}

function ui_refreshWindows(pid) {
	ui_showPlayerWindow(pid);
	ui_showResourceWindow(pid);
	ui_showPurchaseWindow(pid);
	ui_showDevCardWindow(pid)
}

function ui_writeLog(txt) {
	g('log_window').innerHTML = txt + '<br/>' + g('log_window').innerHTML;
}

function ui_showStealWindow(pid) {
	var victims = new Array();
	for (var v = 0; v < 6; ++v) {
		var own = vertexOwner(robberPos.i, robberPos.j, v);
		if (own >= 0 && own != pid) {
			if (players[own].numResources() > 0) {
				var existed = false;
				for (var i = 0; i < victims.length; ++i)
					if (victims[i] == own)
						existed = true;
				if (!existed)
					victims.push(own);
			}
		}
	}

	var txt = 'Steal from:<br/>';
	for (var i = 0; i < victims.length; ++i)
		txt += '<a href="#" onmousedown="state.customHandler(' + victims[i] + ');return false;">' + players[victims[i]].name + '</a><br/>';
	g('steal_window').innerHTML = txt;
	g('steal_window').style.visibility = 'visible';
}

function ui_hideStealWindow() {
	g('steal_window').style.visibility = 'hidden';	
}

//////////////////////////////////////////// BEGIN action functions

function pub_rollForResources(a, pid) {
	ui_drawDice(a);
	var outcome = 0;
	for (var i = 0; i < game.numDice; ++i)
		outcome += parseInt(a[i]);
	if (outcome == game.robberOutcome)
		return false;

	var gain = new Array(numPlayers);
	for (var i = 0; i < numPlayers; ++i) {
		gain[i] = new Array(game.numResourceTypes);
		for (var j = 0; j < game.numResourceTypes; ++j)
			gain[i][j] = 0;
	}
	var cells = outcomeCellMap[outcome];
	if (!cells) return true;
	for (var i = 0; i < cells.length; ++i) {
		var o = cells[i];
		if (o.i == robberPos.i && o.j == robberPos.j) continue;
		var resType = cellResources[o.i][o.j];
		if (resType < 0) continue;
		for (var v = 0; v < 6; ++v) {
			var b = vertexBuilding(o.i, o.j, v);
			if (!b) continue;
			switch (b.type) {
				case game.SETT: gain[b.owner][resType]++; break;
				case game.CITY: gain[b.owner][resType] += 2; break;
				default: break;
			}
		}
	}
	for (var i = 0; i < numPlayers; ++i)
		players[i].addResources(gain[i]);

	for (var i = 0; i < numPlayers; ++i)
		ui_writeLog(players[i].name + ' got ' + resourcesToString(gain[i]) + '.');

	return true;
}

function priv_rollForResources() {
	var a = roll();
	var txt = '';
	for (var i = 0; i < game.numDice; ++i)
		txt += ' ' + a[i];
	sendRemoteMessage('roll ' + myId + txt);
	return pub_rollForResources(a, myId);
}


function pub_buildRoad(i, j, e, isFree, pid) {
	if (!isFree)
		players[pid].subtractResources(game.roadCost);
	players[pid].buildRoad(i, j, e);
	var o = canonicalEdge(i, j, e);
	var x = vertexXY(i, j, e).x;
	var y = vertexXY(i, j, e).y;
	var road = document.createElement('img');
	road.setAttribute('src', 'img/road' + o.e + '_' + pid + '.gif');
	road.style.position = 'absolute';
	switch (o.e) {
		case 0:
			road.style.left = (x + game.XDELTA) + 'px';
			road.style.top = (y-2 + game.YDELTA) + 'px';
			break;
		case 1:
			road.style.left = (x + game.XDELTA) + 'px';
			road.style.top = (y + game.YDELTA) + 'px';
			break;
		case 2:
			road.style.left = (x-19 + game.XDELTA) + 'px';
			road.style.top = (y+ game.YDELTA) + 'px';
			break;
	}
	g('roads').appendChild(road);
}

function priv_buildRoad(i, j, e, isFree, ignoreReachability) {
	if (!players[myId].buildRoadCheck(i, j, e, ignoreReachability)) return false;
	pub_buildRoad(i, j, e, isFree, myId);
	if (isFree)
		sendRemoteMessage('build_road ' + myId + ' ' + i + ' ' + j + ' ' + e);
	else
		sendRemoteMessage('buy_road ' + myId + ' ' + i + ' ' + j + ' ' + e);
	return true;
}


function pub_buildSett(i, j, v, isFree, pid) {
	if (!isFree)
		players[pid].subtractResources(game.settCost);
	players[pid].buildSett(i, j, v);
	var x = vertexXY(i, j, v).x;
	var y = vertexXY(i, j, v).y;
	var sett = document.createElement('img');
	sett.setAttribute('src', 'img/sett_' + pid + '.gif');
	sett.style.position = 'absolute';
	sett.style.left = (x-10+game.XDELTA) + 'px';
	sett.style.top = (y-10+game.YDELTA) + 'px';
	sett.id = 'sett_id_' + vertexToString(i, j, v);
	g('buildings').appendChild(sett);
}


function priv_buildSett(i, j, v, isFree, ignoreReachability) {
	if (!players[myId].buildSettCheck(i, j, v, ignoreReachability)) return false;
	if (isFree)
		sendRemoteMessage('build_sett ' + myId + ' ' + i + ' ' + j + ' ' + v);
	else
		sendRemoteMessage('buy_sett ' + myId + ' ' + i + ' ' + j + ' ' + v);
	pub_buildSett(i, j, v, isFree, myId);
	return true;
}


function pub_buildCity(i, j, v, pid) {
	players[pid].subtractResources(game.cityCost);
	players[pid].buildCity(i, j, v);
	var img = g('sett_id_' + vertexToString(i, j, v));
	img.src = 'img/city_' + pid + '.gif';
}

function priv_buildCity(i, j, v) {
	if (!players[myId].buildCityCheck(i, j, v)) return false;
	sendRemoteMessage('buy_city ' + myId + ' ' + i + ' ' + j + ' ' + v);
	pub_buildCity(i, j, v, myId);
	return true;
}

function pub_buyCard(type, pid) {
	players[pid].devCards.push(devCardBase[type].take());
}

function priv_buyCard() {
	var index = drawDevCard();
	sendRemoteMessage('buy_devcard ' + myId + ' ' + index);
	pub_buyCard(index, myId);
}

function pub_placeRobber(i, j, pid) {
	robberPos = { i: i, j: j };
	g('robber').style.left = (cellXY(i, j).x + 45 + game.XDELTA) + 'px';
	g('robber').style.top = (cellXY(i, j).y + 25 + game.YDELTA) + 'px';
	g('robber').style.visibility = 'visible';
}

function priv_placeRobber(i, j) {
	if (robberPos.i < 0 || cellResources[i][j] >= 0 && (i != robberPos.i || j != robberPos.j)) {
		sendRemoteMessage('place_robber ' + myId + ' ' + i + ' ' + j);
		pub_placeRobber(i, j, myId);
		return true;
	}
	alert('Cannot put the robber here!');
	return false;
}

function pub_steal(victim, type, pid) {
	players[victim].resources[type]--;
	players[pid].resources[type]++;
	return type;
}

function priv_steal(victim) {
	var a = new Array();
	for (var i = 0; i < game.numResourceTypes; ++i)
		for (var j = 0; j < players[victim].resources[i]; ++j)
			a.push(i);
	var k = randInt(a.length);
	var type = a[k];
	sendRemoteMessage('steal ' + myId + ' ' + victim + ' ' + type);
	var t = pub_steal(victim, type, myId);
	return true;
}

function pub_transferTurn(next, pid) {
	currentTurn = next;
	if (currentTurn != myId)
		changeState('wait');
	else {
		if (players[myId].buildingCounts[game.ROAD] < 2)
			changeState('build_initial_sett');
		else
			changeState('roll');
	}
}

function priv_transferTurn(next) {
	if (next == null)
		next = (myId + 1) % numPlayers;
	if (players[myId].points() >= game.goalPoints)
		sendRemoteMessage('win ' + myId + ' ' + players[myId].points());
	else
		sendRemoteMessage('transfer ' + myId + ' ' + next);
	pub_transferTurn(next, myId);
}

function pub_useCard(index, pid) {
	var card = players[pid].devCards[index];
	players[pid].devCards.splice(index, 1);
}

function priv_useCard(index) {
	var card = players[myId].devCards[index];
	sendRemoteMessage('use_card ' + myId + ' ' + index);
	ui_writeLog(players[myId].name + ' played ' + card.name + '.');
	pub_useCard(index, myId);
	card.use();
}

function pub_adjustExtraPoints(inc, pid) {
	players[pid].extraPoints += inc;
}

function priv_adjustExtraPoints(inc) {
	sendRemoteMessage('adjust_extra ' +  myId + ' ' + inc);
	pub_adjustExtraPoints(inc, myId);
}

function pub_getResources(gain, pid) {
	players[pid].addResources(gain, true);
}

function priv_getInitialResources() {
	var gain = create1DArray(game.numResourceTypes);
	var i = initialSett.i, j = initialSett.j;
	if (isValidCell(i, j) && cellResources[i][j] >= 0)
		gain[cellResources[i][j]]++;
	var i2 = i + commonVertex[initialSett.v][0].i;
	var j2 = j + commonVertex[initialSett.v][0].j;
	if (isValidCell(i2, j2) && cellResources[i2][j2] >= 0)
		gain[cellResources[i2][j2]]++;
	var i3 = i + commonVertex[initialSett.v][1].i;
	var j3 = j + commonVertex[initialSett.v][1].j;
	if (isValidCell(i3, j3) && cellResources[i3][j3] >= 0)
		gain[cellResources[i3][j3]]++;
	sendRemoteMessage('get_resources ' + myId + ' ' + dumpArray(gain));
	pub_getResources(gain, myId);
}

function cat_initRoll(pid) {
	var a = roll();
	var txt = '';
	var outcome = 0;
	for (var i = 0; i < game.numDice; ++i) {
		txt += a[i] + ' ';
		outcome += a[i];
	}
	initRolls[pid] = outcome;
	// determine next roller
	var index = 0;
	for (var i = 0; i < tiedPlayers.length; ++i)
		if (tiedPlayers[i] == pid)
			index = i;
	if (index < tiedPlayers.length - 1)
		return tiedPlayers[index+1];
	return -1;
}

function cat_initRollFinishRound() {
	var highest = 0;
	for (var i = 0; i < tiedPlayers.length; ++i)
		if (initRolls[tiedPlayers[i]] > highest)
			highest = initRolls[tiedPlayers[i]];
	var newTiedPlayers = new Array();
	for (var i = 0; i < tiedPlayers.length; ++i)
		if (initRolls[tiedPlayers[i]] == highest)
			newTiedPlayers.push(tiedPlayers[i]);
	tiedPlayers = newTiedPlayers;
	if (tiedPlayers.length == 1)
		return firstPlayer = tiedPlayers[0];
	else
		return -1;
}

function priv_sendMapData() {
	var s = '';
	s += 'map_data ' + myId + ' ' + board.WIDTH + ' ' + board.HEIGHT;
	s += ' ' + dumpArray(board.data);
	s += ' ' + dumpArray(cellResources);
	s += ' ' + dumpArray(cellMarkers);
	s += ' ' + robberPos.i + ' ' + robberPos.j;
	sendRemoteMessage(s);
}

function priv_startGame() {
	sendRemoteMessage('start_game 0');
}


function regPlayer(name, id) {
	myId = id;
	sendRemoteMessage('register ' + id + ' ' + name);
}

receiveRemoteMessages();

</script>

</html>
